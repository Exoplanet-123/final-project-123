#Aperture Calculator Prototype

Data from the _Spitzer Space Telescope_ looks like a series of many frames (of order 10^4), each of which include the star-plus-planet system of interest. An improtant question to answer when analyzing this data is how much of each frame to include in an analysis. If too much of the frame is used then abundant background noise is included and a result will have large uncertainties. If too little is included then important information from the system could be eliminated, which could lead to a "wrong" result.

To determine how much of a frame to include, a circle, or aperture, is drawn around the system and tested for residual noise. Currently the method of determining the best aperture involves testing several apertures, running full simulations, and comparing the different residual noise values. This process can take many involved hours in which no knowledge of the system or the instrument systematics are gained. We aim to find a decent proxy for proividing a narrow lower and upper bound for possible best apertures for a given dataset. A successful algorithm can be applied to multiple star systems in multiple wavelengths, and run without human involvement after initialization.

From the development of this prototytpe we learned a lot about the structure of the data. We focus on a single basic calibrated data (BCD) file taken by _Spitzer_ of the exoplanet HD 209458b in a wavelength bandpass centered on 3.6 microns. The data are stored in .fits files. FITS files allow for much more depth of information in a given pixel in the image than do PNG or JPG image files. 

Using the astropy python package to read the .fits files, we are able to determine where the star-plus-planet system is on the image by determining what the brightest region on the image is. We look for the brightest four squares next to each other. Looking for the brightest region instead of the brightest pixel eliminates the possibility of false positives that could arise from a noise spike in another detector pixel. 

We then determine an acceptable aperture to draw around the brightest region by comparing the amount of flux (how bright a pixel is) within a given aperture (signal) to the flux outside of the aperture (noise). However, this simple comparison is not informative because it does not take into account the fact that the flux outside of the aperture, but closer to the aperture, is more important than the flux at the edges of the frame. We therefore divide up the frame outside the test aperture into circular annuli and weight the amount of flux in each annuli according to a Gaussian curve. We then calculate the ratio of signal to noise. This ratio increases with increasing aperture radius so we also have to add an exponential function as a penalty factor so that the most optimal aperture is not simply the largest possible aperture. 

Our prototype .fits file contains 64 frames. We apply our algorithm for finding the best aperture to all of them, and then take an average. Our prototype code returns a guess for a good aperture to use for the set of 64. Eventually we want to develop this into a method that can guess an upper and lower aperture radius boundary. We will also need to include more frames in our analysis, since the 64 frames we use in our prototype represent less than a minute of actual data (the entire dataset is many hours long). 
